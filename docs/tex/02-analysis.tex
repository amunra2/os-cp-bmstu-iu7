\chapter{Аналитическая часть}

\section{Постановка задачи}

В соответствии с заданием необходимо разрботать загружаемый модуль ядра, который позволит получить следующую информацию:

\begin{itemize}
    \item дерево процессов системы;
    \item открытые процессом файлы (их имя и рамзер);
    \item используемую процессом память (адреса и размер).
\end{itemize}

Также в рамках задания необоходимо разработать пользовательское приложение для вывода информации из загружаемого модуля, а также получить следующую важную информацию об операционной системе Linux:

\begin{itemize}
    \item имя компьютера;
    \item имя пользователя;
    \item версию ядра операционной системы;
    \item время непрерывной работы системы;
    \item модель процессора и его частота;
    \item модель видеокарты;
    \item загруженность процессора;
    \item общее и используемое количество ОЗУ.
\end{itemize}


\section{Способы получения информации о системе}

Для того, чтобы в Linux получить информацию о системе в режиме пользователя, существуют следующие подходы.

\begin{enumerate}
    \item \textbf{Команда dmesg} \cite{dmesg}. Используется для вывода кольцевого буфера ядра. Дает возможность получить сообщения от процессов, которые имеют доступ к ядру. К данной команде применима опция \texttt{grep} для вывода только интересующей части информации.
    \item \textbf{Программа fdisk} \cite{fdisk}. Является инструментом для работы с таблицей разбиения диска. Физические диски обычно разбиваются на несколько логических дисков, которые называются разделами диска. Информация о разбиении физического диска на разделы хранится в таблице разбиения диска, которая находится в нулевом секторе физического диска. Если имеется два или более дисков, и необходимо получить данные о конкретном диске, нужно указать в команде желаемый диск, например \texttt{fdisk -l /dev/<имя>}.
    \item \textbf{Утилита dmidecode} \cite{dmidecode}. Данная утилита выводит содержимое таблицы \texttt{DMI (Desktop Management Interface)} системы в формате, предназначенном для восприятия человеком. Эта таблица содержит информацию, относящуюся к компонентам аппаратного обеспечения системы, а также сведения о версии \texttt{BIOS} и так далее. В выводе \texttt{dmidecode} не только содержится описание текущей конфигурации системы, но и приводятся данные о максимально допустимых значениях параметров, например, о поддерживаемых частотах работы \texttt{CPU}, максимально возможном объеме памяти и так далее.
    \item \textbf{Каталог /proc} \cite{procfs}. Каталог \texttt{/proc} содержит директории и файлы, которые содержат информацию о системе и ее процессах. Из них можно получить информацию об оперативной памяти или центральном процессоре в реальном времени. Поскольку данные хранятся в файлах, то они должны быть прочитаны, а в некоторых случаях, верно интерпретированы пользователем, чтобы получить нужную информацию.
\end{enumerate}

Таким образом, в качестве способа получения информации о системе будет выбран каталог \texttt{/proc}. Он позволяет получить все данные в соответствии с заданием, а также для доступа к файлам не требуются права суперпользователя. То есть информация может быть получена не только администратором компьютера, но и обычным пользователем.


\section{Получение информации о системе}

Каждый файл в каталоге \texttt{/proc} хранит определенные данные о системе. Таким образом, для получения необоходимой по заданию информации нужно обратиться к следующим файлам каталога \texttt{/proc}.


\subsection{Имя компьютера}

Чтобы узнать собственное имя компьютера с помощью \texttt{procfs}, независимое от сетевых интерфейсов, необходимо прочитать информацию из файла \texttt{/proc/sys/kernel/hostname}.


\subsection{Информация о процессоре}

Для получения модели и частоты центрального процессора, необходимо  проанализировать файл \texttt{/proc/cpuinfo}, в котором хранится информация о процессоре и его состоянии в реальном времени. Модель процессора считывается из поля \texttt{model name}, а частота из поля \texttt{cpu MHz}.

\subsection{Информация о видеокарте}

На компьютере, на котором выполнялась курсовая работа, установлена видеокарта от компании \texttt{Nvidia}. По этой причине информацию о видеокарте можно получить из следующего файла в файловой подсистеме \texttt{procfs}: \texttt{/proc/driver/nvidia/gpus/0000:01:00.0/information}.


\subsection{Версия ядра операционной системы}

Информация о версии ядра операционной системе Linux доступна в файле \texttt{/proc/version}. При этом, там также хранится название ОС, версия и название установленного дистрибутива.


\subsection{Загруженность процессора}

Для вычисления процента загруженности центрального процессора, следует проанализировать файл \texttt{/proc/stat}, в котором находится информация об активности процессора. Необходимая информация хранится в первых четырех полях строчки \texttt{cpu}:

\begin{itemize}
    \item число процессов, выполняющихся в режиме пользователя; 
    \item число процессов с изменённым приоритетом (\texttt{nice} \cite{nice}), выполняющихся в режиме пользователя; 
    \item число процессов, выполняющихся в режиме ядра; 
    \item число процессов, выполняющих функцию простоя процессора (\texttt{idle} \cite{idle}).
\end{itemize}


\subsection{Информация об оперативной памяти компьютера}

Информация об оперативной памяти может быть получена путем анализа файла \texttt{/proc/meminfo}. Объем всей оперативной памяти считывается из поля \texttt{MemTotal}, а объем памяти, доступной для немедленного её выделения процессам из поля \texttt{MemAvailable}. Таким образом, объем используемой оперативной памяти вычисляется из разности этих значений.


\section{Загружаемый модуль ядра}

Ядро \texttt{Linux} относится к категории монолитных ядер --- это означает, что большая часть функциональности операционной системы реализована ядром и запускается в привилегированном режиме \cite{vahalia}. Этот подход отличен от подхода микроядра, когда в режиме ядра выполняется только основная функциональность (взаимодействие между процессами, диспетчеризация, базовый ввод-вывод, управление памятью), а остальная функциональность вытесняется за пределы привилегированной зоны (драйверы, сетевой стек, файловые системы).

Ядро \texttt{Linux} динамически изменяемое. Это означает, что можно загружать в ядро дополнительную функциональность, выгружать функции из ядра и даже добавлять новые модули, использующие другие модули ядра. Преимущество загружаемых модулей \cite{vahalia} заключается в возможности сократить расход памяти для ядра, загружая только необходимые модули.

Загружаемые модули ядра имеют ряд фундаментальных отличий от элементов, интегрированных непосредственно в ядро, а также от обычных программ. Обычная программа содержит главную процедуру (\texttt{main}) в отличие от загружаемого модуля, содержащего функции входа и выхода (в версии ядра 2.6 эти функции можно именовать как угодно). 

Функция входа загружаемого модуля ядра вызывается, когда модуль загружается в ядро , а функция выхода –-- соответственно при выгрузке из ядра \cite{vahalia}. Поскольку функции входа и выхода определяются программистом, для указания назначения этих функций используются макросы \texttt{module\_init} и \texttt{module\_exit}. 

Загружаемый модуль содержит также набор обязательных и дополнительных макросов. Они определяют тип лицензии, автора и описание модуля, а также другие параметры.


\subsection{Загрузка и выгрузка загружаемого модуля ядра}

Процесс загрузки модуля начинается в пользовательском пространстве с команды \texttt{insmod}. Команда \texttt{insmod} определяет модуль для загрузки и выполняет системный вызов уровня пользователя \texttt{init\_module} для начала процесса загрузки.

Функция \texttt{init\_module} работает на уровне системных вызовов и вызывает функцию  ядра  \texttt{sys\_init\_module}.  Это  основная  функция  для загрузки модуля, обращающаяся к нескольким другим функциям для решения специальных  задач.  Аналогичным  образом  команда  \texttt{rmmod}  выполняет системный  вызов  функции  \texttt{delete\_module},  которая  обращается  в  ядро  с вызовом \texttt{sys\_delete\_module} для удаления модуля из ядра.


\section{Взаимдействие пространства ядра и пользователя}

В \texttt{Linux} для передачи данных из пространства ядра в пространство пользователя зачастую используется виртуальная файловая система \texttt{procfs}, которая предоставляет системные вызовы для реализации интерфейса между двумя этими пространствами. 

Для работы в системе используется структура \texttt{proc\_ops} определена в файле \texttt{linux/proc\_fs.h} и содержит в себе указатели на функции драйвера, которые отвечают за выполнение различных операций с устройством. Основные поля структуры представлены в листинге \ref{lst:proc-ops}.

\mylisting[c]{proc-ops.c}
        {firstline=1,lastline=78}{Структура \texttt{proc\_ops}}{proc-ops}{}

Также для передачи данных между пространством пользователя и ядра используются две функции -- \texttt{copy\_to\_user} (позволяет копировать блоки данных из пространства ядра в пространство пользователя) и \texttt{copy\_from\_user} (позволяет копировать блоки данных из пространства пользователя в пространство ядра). Определены эти функции в файле \texttt{linux/uaccess.h} \cite{uaccess} и возвращают количество байт, которые не удалось записать.

Для приема управляющих данных и передачи результатов функций в пользовательское приложение целесообразным будет создать три файла в каталоге \texttt{/proc}, каждый из которых будет являться интерфейсом соответствующей функции разрабатываемого модуля. Интерфейс для взаимодействия с пространством пользователя представляется с помощью \texttt{struct proc\_dir\_entry}. Некоторые поля данной структуры представлены в приложении \ref{appendices:d}. 


\section{Получение информации о процессах}

Процесс --- это программа в стадии выполнения. Он состоит из исполняемого программного кода, набора ресурсов (таких, как открытые файлы), внутренних данных ядра, адресного пространства, одного или нескольких потоков исполнения и секции данных, содержащей глобальные переменные. 

С каждым процессом связан (ассоциирован) <<описатель процесса>> или дескриптор процесса. Ядро Linux использует циклически замкнутый двусвязный список записей \texttt{struct task\_struct} (приложение \ref{appendices:a}) для хранения дескрипторов процессов. Эта структура объявлена в файле \texttt{linux/sched.h} \cite{sched}. Дескриптор содержит информацию, используемую для того, чтобы отслеживать процесс в оперативной памяти. В частности, в дескрипторе содержатся идентификатор процесса (\texttt{PID}), его состояние, ссылки на родительский и дочерние процессы, регистры процессора, список открытых файлов и информация об адресном пространстве.


\subsection{Предаставление процессов в памяти}

Строка \texttt{struct list\_head tasks} внутри определения \texttt{struct task\_struct} показывает, что ядро использует циклический связанный список для хранения задач. Это означает, что можно использовать стандартные макросы и функции для работы со связанными списками с целью просмотра полного списка задач. 

<<Родителем всех процессов>> в системе \texttt{Linux} является процесс \texttt{init}. Так что он должен стоять в начале списка, хотя, строго говоря, начала не существует раз речь идет о циклическом списке. Дескриптор процесса \texttt{init} задается статично, о чем говорит следующая строчка в структуре \texttt{extern struct task\_struct init\_task}.

Имеется несколько макросов и функций, которые помогают перемещаться по этому списку:

\begin{itemize}
    \item \texttt{for\_each\_process()} --- это макрос, который проходит весь список задач;
    \item \texttt{next\_task()} --- макрос, определенный в \texttt{linux/sched.h}, возвращает 
    следующую задачу из списка.
\end{itemize}


\subsection{Построение дерева процессов}

Построение дерева процессов основано на иерархии <<предок-потомок>>. Таким образом, для корректного построения дерева необходимо рекурсивно пройти по всем потомкам процесса, начиная с \texttt{init}. При этом необходимо запоминать глубину рекурсии на каждом шаге для корректного отображения дерева.


\subsection{Получение информации о памяти процесса}

Адресное пространство процесса представлено полем \texttt{mm} типа \texttt{struct mm\_struct}. Для получения необходимой информации в рамках задачи интерес представляет поле \texttt{mmap} данной структуры, которое имеет тип \texttt{struct vm\_area\_struct}. Данное поле представляет собой список областей памяти процесса.

Данная структура определена в файле \texttt{linux/mm\_types.h} \cite{mm-types}, некоторые ее поля представлены в приложении \ref{appendices:b}. Особый интерес представляет поле \texttt{vm\_next}, которое указывает на следующую область памяти, а также поля \texttt{vm\_start} и \texttt{vm\_end}, с помощью которых можно получить информацию об адресах начала и конца области памяти, а также вычислить ее размер.


\subsection{Получение информации об открытых процессом файлах}

Для получения информации о файлах, открытых процессом, используется структура \texttt{struct fdtable}, определенная в файле \texttt{linux/fdtable.h} \cite{fdtable} (приложение \ref{appendices:c}). Данная структура имеет поле \texttt{fd}, которое определяет массива указателей на дескрипторы файлов, открытых процессом. Таким образом, обратившись к полям каждого элемента массива \texttt{fd}, можно получить необходимую информацию: размер файла, путь, имя.


\section*{Вывод}

В данном разделе были расммотрены некоторые функции и структуры операцинной системы Linux, которые будут использованы при написании программного продукта. Также были описаны такие понятия системы, как загружаемый модуль ядра, процесс, файловая система \texttt{procfs}.

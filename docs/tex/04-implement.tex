\chapter{Технологическая часть}

\section{Средства реализации}

В качестве языка программирования для написания загружамого модуля ядра был выбран \texttt{C} \cite{c}. Решение обусловлено тем, что сама операционная система \texttt{Linux} \cite{linux} написана на языке \texttt{C}, поэтому все структуры и функции также написаны на нем.

Для написания пользовательского приложения был выбран язык \texttt{C++} \cite{cpp}, так как он обладает широким набором функций, а также графической библиотекой \texttt{Qt} \cite{qt}.

Реализация была написана на дистрибутиве \texttt{Ubuntu 22.04} \cite{ubuntu}, который работает на операционной систем \texttt{Linux} версии \texttt{5.15.0-58}.


\section{Реализация загружаемого модуля ядра}

В листинге \ref{lst:make} представлено содержание \texttt{Makefile} для сборки загружаемого модуля. Также в нем содержится цель \texttt{clean} для очистки файлов, которые создаются при сборке модуля.

\mylisting[make]{Makefile}
        {firstline=1,lastline=9}{Makefile для сборки загружаемого модуля ядра}{make}{}

\subsection{Функции загрузки и выгрузки модуля}

В листинге \ref{lst:init} представлена функция, которая вызывается при загрузке модуля в ядро, а в листинге \ref{lst:exit} --- при выгрузке модуля.

\mylisting[c]{main-kernel.c}
    {firstline=1,lastline=41}{Функция для загрузки модуля}{init}{}
        
\mylisting[c]{main-kernel.c}
    {firstline=44,lastline=54}{Функция для выгрузки модуля}{exit}{}


\subsection{Функции для взаимодействия с файловой системой}

Для взаимодействия с \texttt{procfs} необходимо было написать функции для чтения и записи. В приложении \ref{appendices:e} приведен листинг функций \texttt{read\_proc\_mem()} и \texttt{write\_proc\_mem()}.


\subsection{Функции для получения информации о процессах}

В приложении \ref{appendices:f} представлены листинги функций:

\begin{itemize}
    \item построения дерева процессов;
    \item получения информации об используемой процессом памяти;
    \item получения информации об открытых процессом файлах.
\end{itemize}


\section{Пользовательское приложение}

Собирается проект с помощью автосгенерированного \texttt{Makefile} по проекту в Qt.

\subsection{Взаимодействие с модулем ядра}

В листинге \ref{lst:module-connect} представлена функция для <<подключения>> (проверки того, что он активен и создал файлы в \texttt{procfs}) к загружаемому модулю ядра. А в листинге \ref{lst:mem-get} функция для получения информации из \texttt{procfs} от загружаемого модуля (приведен пример для получения информации о памяти процесса).

\mylisting[c++]{main-app.c}
    {firstline=1,lastline=39}{Функция для <<подключения>> к модулю ядра}{module-connect}{}

\mylisting[c++]{main-app.c}
    {firstline=42,lastline=63}{Функция для получения информации о памяти процесса, полученной от загружаемого модуля}{mem-get}{}


\subsection{Получение информации о системе}

В листинге \ref{lst:get-cpu-model} приведен пример получения информации из системы, путем прочтения файла из каталога \texttt{/proc} (пример получения информации о модели процессора).

\mylisting[c++]{func-app.c}
    {firstline=1,lastline=13}{Функция для получения модели процессора}{get-cpu-model}{}


\section{Демонстрация работы программы}

На рисунке \ref{img:example-all-info} представлен пример вывода общей информации о системе. Также на рисунке \ref{img:example-process-info} приведен пример вывода информации о памяти и открытых файлах процесса. При этом на рисунке \ref{img:example-tree} показан пример дерева процессов.

\imgs{example-all-info}{h!}{0.4}{Пример информации о системе}
\imgs{example-process-info}{h!}{0.4}{Пример информации о памяти и открытых файлах процесса}
\imgs{example-tree}{h!}{0.4}{Пример дерева процессов}


\section*{Вывод}

В данной разделе приведены средства реализации (для модуля язык \texttt{C}, для пользовательского приложения язык \texttt{C++}). Также представлены листинги основных функций программного продукта.
